(function (w) {
    w.drewsnow = {
        'draggable': (container, dragItem) => {
            if (dragItem === undefined) dragItem = container;

            var xOffset = yOffset = 0,
                active = false,
                currentX,
                currentY,
                initialX,
                initialY;

            container.addEventListener('touchstart', dragStart, false);
            document.addEventListener('touchend', dragEnd, false);
            document.addEventListener('touchmove', drag, false);

            container.addEventListener('mousedown', dragStart, false);
            document.addEventListener('mouseup', dragEnd, false);
            document.addEventListener('mousemove', drag, false);

            function dragStart(e) {
                if (e.type === 'touchstart') {
                    initialX = e.touches[0].clientX - xOffset;
                    initialY = e.touches[0].clientY - yOffset;
                } else {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                }
                let ignoredElems = ['INPUT', 'BUTTON', 'A', 'P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6'];
                if (e.target === dragItem || container === dragItem && ignoredElems.indexOf(e.target.nodeName) == -1) active = true;
            }

            function dragEnd(e) {
                initialX = currentX;
                initialY = currentY;
                active = false;
            }

            function drag(e) {
                if (active) {
                    e.preventDefault();
                    if (e.type === 'touchmove') {
                        currentX = e.touches[0].clientX - initialX;
                        currentY = e.touches[0].clientY - initialY;
                    } else {
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                    }
                    xOffset = currentX;
                    yOffset = currentY;
                    setTranslate(currentX, currentY, container);
                }
            }

            function setTranslate(xPos, yPos, el) {
                el.style.transform = 'translate3d(' + xPos + 'px, ' + yPos + 'px, 0)';
            }
        },

        'addStyle': (css) => {
            let elem = document.createElement('style');
            elem.textContent = css;
            document.head.appendChild(elem);
            return elem;
        },

        'addHtml': (html, parent) => {
            elements = new DOMParser().parseFromString(html, 'text/html');
            container = elements.body.firstChild;
            (parent || document.body).appendChild(container);
            return container;
        },

        'injectScript': (script) => {
            let elem = document.createElement('script');
            elem.type = 'text/javascript';
            elem.textContent = script;
            elem.onload = function () { this.remove() };
            document.body.appendChild(elem);
        },

        'htmlEncode': (str) => {
            return str
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        },

        'addKeyBind': function (func, code = -1, key = '', bool = false) {
            this.keybinds.push({
                'key': key,
                'on': bool,
                'func': func,
                'code': code
            });
            if (bool) func();
        },

        'removeKeyBind': function (code) {
            for (let i = 0; i < this.keybinds.length; i++) {
                let binds = this.keybinds;
                if (binds[i].code === code) {
                    binds.splice(i, 1);
                    return true;
                }
            }
            return false;
        },

        'keybinds': [],

        'getAngle': (x1, y1, x2, y2) => {
            return Math.atan2(y1 - y2, x1 - x2);
        },

        'getDist': (x1, y1, x2, y2) => {
            var a = x1 - x2;
            var b = y1 - y2;
            return Math.sqrt(a * a + b * b);
        },

        'closestObj': function (you, objects) {
            let closestObj = objects[0];
            let closestDist = Infinity;
            for (let i = 0; i < objects.length; i++) {
                let obj = objects[i],
                    dist = this.getDist(you.x, you.y, obj.x, obj.y);
                if (dist < closestDist) {
                    closestObj = obj;
                    closestDist = dist;
                }
            }
            return closestObj;
        },

        'init': function () {
            const binds = this.keybinds;
            document.body.addEventListener('keydown', (e) => {
                for (let i = 0; i < binds.length; i++) {
                    let data = binds[i];
                    if ((e.which || e.keyCode) == data.code) {
                        data.on = !data.on;
                        data.func();
                    }
                }
            });

            const elem = this.addHtml(`
                <div style="box-sizing: content-box; transition: transform 1s ease; transform: translateX(125%); border-radius: 3px 0 0 3px; font-family: Consolas, monaco, monospace; position: fixed; bottom: 20px; right: 0; width: 250px; height: 75px; background-color: #11af00; color: #e2e2e2; box-shadow: 0 5px 35px rgba(0, 0, 0, .65); text-align: center; line-height: 1; font-size: 25px; padding-top: 15px;">Scripted By<br><span style="font-size: 30px; color: #fff; border-bottom: 2px solid #00ff2a;">Drew Snow</span></div>
            `);

            setTimeout(() => { elem.style.transform = ''; }, 0);

            setTimeout(() => { elem.style.transform = 'translateX(125%)'; }, 4000);

            setTimeout(() => { elem.remove(); }, 5250);
        }
    }
    w.drewsnow.init();
})(window);
